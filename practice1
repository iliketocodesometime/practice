# ... (pre-existing code)

# Dynamic Quartiling
breakdown = [50, 30, 10, 10]
assert sum(breakdown) == 100, "Breakdown percentages should sum to 100."

# Calculate cumulative sum for easy checking later
cumulative_breakdown = [sum(breakdown[:i+1]) for i in range(len(breakdown))]
bin_limits = len(fa_full_info_df) * np.array(cumulative_breakdown) / 100

fa_full_info_df = fa_full_info_df.sort_values(by="Funded %", ascending=False)
fa_full_info_df["Bin"] = np.digitize(range(len(fa_full_info_df)), bin_limits, right=False)

# Pre-Process Leads
leads_with_geo_df = pd.merge(PR360_LEAD_DIST_ACCESS_FINAL_OUTPUT_df, geo_index_df, left_on='CDE_MAIL_ZIP', right_on='Zip', how="left")
leads_with_geo_good_df = leads_with_geo_df[leads_with_geo_df['Zip'].notnull()]

# Track how many leads have been assigned to each bin
leads_assigned_per_bin = {i: 0 for i in range(1, len(breakdown)+1)}
total_leads = len(leads_with_geo_good_df)
max_leads_per_bin = {i: total_leads * breakdown[i-1] / 100 for i in range(1, len(breakdown)+1)}

# Function to get FA location based on LocationGran
def get_fa_location(row, column):
    return row[column]

# Updated lead assignment loop
for index, row in leads_with_geo_good_df.iterrows():
    for bin_num in range(1, len(breakdown)+1):
        if leads_assigned_per_bin[bin_num] < max_leads_per_bin[bin_num]:
            potential_FAs = fa_full_info_df[(fa_full_info_df["Bin"] == bin_num) & 
                                           (row['AMT_TOT_AMT_PRDY'] <= fa_full_info_df['AUM Maximum']) & 
                                           (row['AMT_TOT_AMT_PRDY'] >= fa_full_info_df['AUM Minimum']) & 
                                           (row['LATEST_IXI'] <= fa_full_info_df['AUM Maximum']) & 
                                           (row['LATEST_IXI'] >= fa_full_info_df['AUM Minimum'])]
            
            # Location Granularity
            LocationGran = "City_Branch"  # Set as per requirement
            if LocationGran == "City_Branch":
                location_column = "City_Branch"
            elif LocationGran == "State":
                location_column = "State"
            else:  # Region
                location_column = "Region"
                
            if not potential_FAs.empty:
                potential_FAs['distance'] = potential_FAs.apply(lambda x: haversine(row['Longitude'], row['Latitude'], x['CityLon'], x['CityLat']), axis=1)
                closest_location = get_fa_location(potential_FAs.loc[potential_FAs['distance'].idxmin()], location_column)
                location_FAs = potential_FAs[potential_FAs[location_column] == closest_location]
                location_FAs = location_FAs.sort_values(by="Date Posted")
                chosen_FA = location_FAs.iloc[0]
                leads_assigned_per_bin[bin_num] += 1
                break  # Break once we've assigned a lead for this bin and move to next lead

# ... (rest of the script)
